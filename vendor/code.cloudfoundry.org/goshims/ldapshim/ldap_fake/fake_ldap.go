// Code generated by counterfeiter. DO NOT EDIT.
package ldap_fake

import (
	"crypto/tls"
	"sync"

	"code.cloudfoundry.org/goshims/ldapshim"
	ldap "gopkg.in/ldap.v2"
)

type FakeLdap struct {
	DialStub        func(network, addr string) (ldapshim.LdapConnection, error)
	dialMutex       sync.RWMutex
	dialArgsForCall []struct {
		network string
		addr    string
	}
	dialReturns struct {
		result1 ldapshim.LdapConnection
		result2 error
	}
	dialReturnsOnCall map[int]struct {
		result1 ldapshim.LdapConnection
		result2 error
	}
	DialTLSStub        func(network, addr string, config *tls.Config) (ldapshim.LdapConnection, error)
	dialTLSMutex       sync.RWMutex
	dialTLSArgsForCall []struct {
		network string
		addr    string
		config  *tls.Config
	}
	dialTLSReturns struct {
		result1 ldapshim.LdapConnection
		result2 error
	}
	dialTLSReturnsOnCall map[int]struct {
		result1 ldapshim.LdapConnection
		result2 error
	}
	NewSearchRequestStub        func(string, int, int, int, int, bool, string, []string, []ldap.Control) *ldap.SearchRequest
	newSearchRequestMutex       sync.RWMutex
	newSearchRequestArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 int
		arg6 bool
		arg7 string
		arg8 []string
		arg9 []ldap.Control
	}
	newSearchRequestReturns struct {
		result1 *ldap.SearchRequest
	}
	newSearchRequestReturnsOnCall map[int]struct {
		result1 *ldap.SearchRequest
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLdap) Dial(network string, addr string) (ldapshim.LdapConnection, error) {
	fake.dialMutex.Lock()
	ret, specificReturn := fake.dialReturnsOnCall[len(fake.dialArgsForCall)]
	fake.dialArgsForCall = append(fake.dialArgsForCall, struct {
		network string
		addr    string
	}{network, addr})
	fake.recordInvocation("Dial", []interface{}{network, addr})
	fake.dialMutex.Unlock()
	if fake.DialStub != nil {
		return fake.DialStub(network, addr)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.dialReturns.result1, fake.dialReturns.result2
}

func (fake *FakeLdap) DialCallCount() int {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return len(fake.dialArgsForCall)
}

func (fake *FakeLdap) DialArgsForCall(i int) (string, string) {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return fake.dialArgsForCall[i].network, fake.dialArgsForCall[i].addr
}

func (fake *FakeLdap) DialReturns(result1 ldapshim.LdapConnection, result2 error) {
	fake.DialStub = nil
	fake.dialReturns = struct {
		result1 ldapshim.LdapConnection
		result2 error
	}{result1, result2}
}

func (fake *FakeLdap) DialReturnsOnCall(i int, result1 ldapshim.LdapConnection, result2 error) {
	fake.DialStub = nil
	if fake.dialReturnsOnCall == nil {
		fake.dialReturnsOnCall = make(map[int]struct {
			result1 ldapshim.LdapConnection
			result2 error
		})
	}
	fake.dialReturnsOnCall[i] = struct {
		result1 ldapshim.LdapConnection
		result2 error
	}{result1, result2}
}

func (fake *FakeLdap) DialTLS(network string, addr string, config *tls.Config) (ldapshim.LdapConnection, error) {
	fake.dialTLSMutex.Lock()
	ret, specificReturn := fake.dialTLSReturnsOnCall[len(fake.dialTLSArgsForCall)]
	fake.dialTLSArgsForCall = append(fake.dialTLSArgsForCall, struct {
		network string
		addr    string
		config  *tls.Config
	}{network, addr, config})
	fake.recordInvocation("DialTLS", []interface{}{network, addr, config})
	fake.dialTLSMutex.Unlock()
	if fake.DialTLSStub != nil {
		return fake.DialTLSStub(network, addr, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.dialTLSReturns.result1, fake.dialTLSReturns.result2
}

func (fake *FakeLdap) DialTLSCallCount() int {
	fake.dialTLSMutex.RLock()
	defer fake.dialTLSMutex.RUnlock()
	return len(fake.dialTLSArgsForCall)
}

func (fake *FakeLdap) DialTLSArgsForCall(i int) (string, string, *tls.Config) {
	fake.dialTLSMutex.RLock()
	defer fake.dialTLSMutex.RUnlock()
	return fake.dialTLSArgsForCall[i].network, fake.dialTLSArgsForCall[i].addr, fake.dialTLSArgsForCall[i].config
}

func (fake *FakeLdap) DialTLSReturns(result1 ldapshim.LdapConnection, result2 error) {
	fake.DialTLSStub = nil
	fake.dialTLSReturns = struct {
		result1 ldapshim.LdapConnection
		result2 error
	}{result1, result2}
}

func (fake *FakeLdap) DialTLSReturnsOnCall(i int, result1 ldapshim.LdapConnection, result2 error) {
	fake.DialTLSStub = nil
	if fake.dialTLSReturnsOnCall == nil {
		fake.dialTLSReturnsOnCall = make(map[int]struct {
			result1 ldapshim.LdapConnection
			result2 error
		})
	}
	fake.dialTLSReturnsOnCall[i] = struct {
		result1 ldapshim.LdapConnection
		result2 error
	}{result1, result2}
}

func (fake *FakeLdap) NewSearchRequest(arg1 string, arg2 int, arg3 int, arg4 int, arg5 int, arg6 bool, arg7 string, arg8 []string, arg9 []ldap.Control) *ldap.SearchRequest {
	var arg8Copy []string
	if arg8 != nil {
		arg8Copy = make([]string, len(arg8))
		copy(arg8Copy, arg8)
	}
	var arg9Copy []ldap.Control
	if arg9 != nil {
		arg9Copy = make([]ldap.Control, len(arg9))
		copy(arg9Copy, arg9)
	}
	fake.newSearchRequestMutex.Lock()
	ret, specificReturn := fake.newSearchRequestReturnsOnCall[len(fake.newSearchRequestArgsForCall)]
	fake.newSearchRequestArgsForCall = append(fake.newSearchRequestArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 int
		arg6 bool
		arg7 string
		arg8 []string
		arg9 []ldap.Control
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9Copy})
	fake.recordInvocation("NewSearchRequest", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9Copy})
	fake.newSearchRequestMutex.Unlock()
	if fake.NewSearchRequestStub != nil {
		return fake.NewSearchRequestStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newSearchRequestReturns.result1
}

func (fake *FakeLdap) NewSearchRequestCallCount() int {
	fake.newSearchRequestMutex.RLock()
	defer fake.newSearchRequestMutex.RUnlock()
	return len(fake.newSearchRequestArgsForCall)
}

func (fake *FakeLdap) NewSearchRequestArgsForCall(i int) (string, int, int, int, int, bool, string, []string, []ldap.Control) {
	fake.newSearchRequestMutex.RLock()
	defer fake.newSearchRequestMutex.RUnlock()
	return fake.newSearchRequestArgsForCall[i].arg1, fake.newSearchRequestArgsForCall[i].arg2, fake.newSearchRequestArgsForCall[i].arg3, fake.newSearchRequestArgsForCall[i].arg4, fake.newSearchRequestArgsForCall[i].arg5, fake.newSearchRequestArgsForCall[i].arg6, fake.newSearchRequestArgsForCall[i].arg7, fake.newSearchRequestArgsForCall[i].arg8, fake.newSearchRequestArgsForCall[i].arg9
}

func (fake *FakeLdap) NewSearchRequestReturns(result1 *ldap.SearchRequest) {
	fake.NewSearchRequestStub = nil
	fake.newSearchRequestReturns = struct {
		result1 *ldap.SearchRequest
	}{result1}
}

func (fake *FakeLdap) NewSearchRequestReturnsOnCall(i int, result1 *ldap.SearchRequest) {
	fake.NewSearchRequestStub = nil
	if fake.newSearchRequestReturnsOnCall == nil {
		fake.newSearchRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.SearchRequest
		})
	}
	fake.newSearchRequestReturnsOnCall[i] = struct {
		result1 *ldap.SearchRequest
	}{result1}
}

func (fake *FakeLdap) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	fake.dialTLSMutex.RLock()
	defer fake.dialTLSMutex.RUnlock()
	fake.newSearchRequestMutex.RLock()
	defer fake.newSearchRequestMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLdap) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ldapshim.Ldap = new(FakeLdap)
